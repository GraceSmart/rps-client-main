{"remainingRequest":"/Users/gracesmart/Desktop/rps-client-main/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/gracesmart/Desktop/rps-client-main/src/components/Gesture.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"/Users/gracesmart/Desktop/rps-client-main/src/components/Gesture.vue","mtime":1624639519000},{"path":"/Users/gracesmart/Desktop/rps-client-main/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/gracesmart/Desktop/rps-client-main/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/gracesmart/Desktop/rps-client-main/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/gracesmart/Desktop/rps-client-main/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/gracesmart/Desktop/rps-client-main/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKdmlkZW8gewogIHdpZHRoOiAxMDAlOwp9Cg=="},{"version":3,"sources":["Gesture.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiLA;AACA;AACA","file":"Gesture.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <v-card-text>\n    <v-select\n      :items=\"devices\"\n      v-model=\"videoDevice\"\n      item-text=\"label\"\n      item-value=\"deviceId\"\n    />\n    <video ref=\"video\"></video>\n    <div>\n      <table>\n        <tr v-for=\"(prediction, index) in predictions\" v-bind:key=\"index\">\n          <td>\n            <label :for=\"prediction.name\">{{ prediction.name }}</label>\n          </td>\n          <td>\n            <meter\n              :id=\"prediction.name\"\n              :value=\"prediction.score\"\n              min=\"0\"\n              max=\"100\"\n            />\n          </td>\n        </tr>\n      </table>\n    </div>\n  </v-card-text>\n</template>\n\n<script>\nimport * as tf from \"@tensorflow/tfjs\";\nimport * as tmImage from \"@teachablemachine/image\";\nexport default {\n  name: \"App\",\n  components: {},\n  data() {\n    return {\n      videoDevice: \"\",\n      devices: [],\n      baseModel: \"mobilenet_v2\",\n      isModelReady: false,\n      predictions: [\n        { name: 'Rock', score: 0 },\n        { name: 'Paper', score: 0 },\n        { name: 'Scissors', score: 0 }\n      ],\n      lastPrediction: \"\",\n    };\n  },\n  mounted() {\n    tf.setBackend(\"webgl\");\n    this.listVideoDevices()\n      .then((videoDevices) => {\n        for (let device of videoDevices) {\n          this.devices.push(device);\n        }\n        this.videoDevice = videoDevices[0].deviceId;\n      })\n      .then(() => {\n        return this.initWebcamStream();\n      })\n      .then(() => {\n        return this.loadModel().then(() => {\n          this.detectObjects();\n        });\n      });\n  },\n  beforeDestroy() {\n    if (this.raf) {\n      let video = this.$refs.video\n      video.pause()\n      video.srcObject = null\n      \n      this.stream.getTracks().forEach(track => {\n        track.stop()\n      })\n      this.isVideoStreamReady = false\n      cancelAnimationFrame(this.raf)\n    }\n  },\n  methods: {\n    listVideoDevices() {\n      return navigator.mediaDevices.enumerateDevices().then((devices) => {\n        return devices.filter((device) => device.kind === \"videoinput\");\n      });\n    },\n    initWebcamStream() {\n      this.isVideoStreamReady = false;\n      // if the browser supports mediaDevices.getUserMedia API\n      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n        return (\n          navigator.mediaDevices\n            .getUserMedia({\n              video: { deviceId: this.videoDevice },\n            })\n            .then((stream) => {\n              this.stream = stream\n              // set <video> source as the webcam input\n              let video = this.$refs.video\n              video.srcObject = this.stream;\n              return new Promise((resolve) => {\n                // when video is loaded\n                video.onloadedmetadata = () => {\n                  // calculate the video ratio\n                  this.videoRatio = video.videoHeight / video.videoWidth;\n                  // add event listener on resize to reset the <video> and <canvas> sizes\n                  this.isVideoStreamReady = true;\n                  video.play()\n                  resolve();\n                };\n              });\n            })\n            // error handling\n            .catch((error) => {\n              console.log(\"failed to initialize webcam stream\", error);\n            })\n        );\n      }\n    },\n    loadModel() {\n      return tmImage\n        .load(\"/gesture/model.json\", \"/gesture/metadata.json\")\n        .then((model) => {\n          this.model = model;\n          this.isModelReady = true;\n        })\n        .catch((error) => {\n          console.log(\"failed to load the mode\", error);\n          throw error;\n        });\n    },\n    detectObjects() {\n      if (!this.isModelReady) return;\n      if (this.isVideoStreamReady) {\n        this.model.predict(this.$refs.video).then((predictions) => {\n          this.handlePredictions(predictions);\n          this.raf = requestAnimationFrame(() => {\n            this.detectObjects();\n          });\n        });\n      } else {\n        this.raf = requestAnimationFrame(() => {\n          this.detectObjects();\n        });\n      }\n    },\n    handlePredictions(predictions) {\n      this.predictions.splice(0);\n      let maxPrediction;\n      let maxProb = 0;\n      predictions.forEach((prediction) => {\n        this.predictions.push({\n          name: prediction.className,\n          score: (prediction.probability * 100).toFixed(1),\n        });\n        if (prediction.probability > maxProb) {\n          maxProb = prediction.probability;\n          maxPrediction = prediction;\n        }\n      });\n      if (this.lastPrediction != maxPrediction.className) {\n        this.lastPrediction = maxPrediction.className;\n        if (this.timeout) {\n          clearTimeout(this.timeout)\n        }\n        this.timeout = setTimeout(() => {\n          if (this.lastPrediction != 'Nothing') {\n            this.$emit('gesture', this.lastPrediction.toLowerCase())\n          }\n        }, 1500)\n      }\n    },\n  },\n};\n</script>\n\n<style>\nvideo {\n  width: 100%;\n}\n</style>"]}]}