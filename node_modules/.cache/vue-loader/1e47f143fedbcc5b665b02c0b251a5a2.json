{"remainingRequest":"/Users/gracesmart/Desktop/rps-client-main/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/gracesmart/Desktop/rps-client-main/src/components/Speech.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"/Users/gracesmart/Desktop/rps-client-main/src/components/Speech.vue","mtime":1624639572000},{"path":"/Users/gracesmart/Desktop/rps-client-main/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/gracesmart/Desktop/rps-client-main/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/gracesmart/Desktop/rps-client-main/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/gracesmart/Desktop/rps-client-main/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/gracesmart/Desktop/rps-client-main/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLmFwcCB7CiAgZm9udC1mYW1pbHk6IEF2ZW5pciwgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjsKICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDsKICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlOwogIGNvbG9yOiAjMmMzZTUwOwogIG1hcmdpbi10b3A6IDYwcHg7Cn0KdGFibGUgewogIHdpZHRoOiAxMDAlOwogIGJvcmRlci1zcGFjaW5nOiA1cHg7Cn0KLm1hcmdpbi0xMCB7CiAgbWFyZ2luOiAxMHB4Owp9Ci50b3Atcm93IHsKICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDIwMCwgMCwgMC4xKTsKICBoZWlnaHQ6IDQwcHg7CiAgZm9udC13ZWlnaHQ6IDkwMDsKfQoub3RoZXItcm93cyB7CiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDAsIDAsIDAsIDAuMSk7CiAgaGVpZ2h0OiAzMHB4OwogIGZvbnQtd2VpZ2h0OiA0MDA7Cn0KdGQgewogIHBhZGRpbmc6IDVweDsKfQp0ZDpudGgtY2hpbGQoMSkgewogIHdpZHRoOiA3MCU7CiAgICB0ZXh0LWFsaWduOiBsZWZ0Owp9CnRkOm50aC1jaGlsZCgyKSB7CiAgd2lkdGg6IDMwJTsKICB0ZXh0LWFsaWduOiBjZW50ZXI7Cn0KLmNlbnRlci1jb250YWluZXIgewogIHdpZHRoOiA2MDBweDsKICBtYXJnaW46IDAgYXV0bzsKfQouZGV2aWNlLXNlbGVjdCB7CiAgd2lkdGg6IDEwMCU7Cn0K"},{"version":3,"sources":["Speech.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Speech.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <v-card-text>\n    <v-select\n      :items=\"audioDevices\"\n      v-model=\"audioDevice\"\n      item-text=\"label\"\n      item-value=\"deviceId\"\n    />\n    <v-simple-table>\n      <tbody>\n      <tr v-if=\"topPrediction != null\">\n        <td>{{ topPrediction.name }}</td>\n        <td>{{ topPrediction.score }} %</td>\n      </tr>\n      <tr v-else>\n        <td>Not sure...</td>\n      </tr>\n      <tr v-for=\"(prediction, index) in filteredSortedPredictions\" v-bind:key=\"index\">\n        <td>{{prediction.name}}</td>\n        <td>{{prediction.score}} %</td>\n      </tr>\n      </tbody>\n    </v-simple-table>\n  </v-card-text>\n</template>\n\n<script>\nimport * as tf from '@tensorflow/tfjs'\nimport * as speechCommands from '@tensorflow-models/speech-commands'\nexport default {\n  name: 'App',\n  data () {\n    return {\n      isModelReady: false,\n      predictions: [],\n      audioTrackConstraints: {},\n      audioDevices: [],\n      audioDevice: ''\n    }\n  },\n  watch: {\n    audioDevice: function (deviceId) {\n      if (this.recognizer) {\n        this.setupRecognizer(deviceId)\n      }\n    }\n  },\n  computed: {\n    sortedPredictions () {\n      const predictions = [...this.predictions]\n      predictions.sort((a, b) => {\n        return (b.score - a.score)\n      })\n      return predictions\n    },\n    topPrediction () {\n      if (this.sortedPredictions.length > 0) {\n        return this.sortedPredictions[0]\n      }\n      else {\n        return null\n      }\n    },\n    filteredSortedPredictions () {\n      const t = this.topPrediction\n      return this.sortedPredictions.filter(p => p != t)\n    }\n  },\n  async mounted () {\n    tf.setBackend('webgl')\n    const enumeratorPromise = navigator.mediaDevices.enumerateDevices()\n    enumeratorPromise.then(async devices => {\n      devices.forEach(device => {\n        if (device.kind === 'audioinput') {\n          this.audioDevices.push(device)\n        }\n      })\n      this.audioDevice = this.audioDevices[0].deviceId\n      this.recognizer = await this.createModel()\n      this.classLabels = this.recognizer.wordLabels() // get class labels\n      \n      this.setupRecognizer(this.audioDevice)\n    })\n  },\n  beforeDestroy() {\n    if (this.recognizer) {\n      this.recognizer.stopListening()\n    }\n  },\n  methods: {\n    async setupRecognizer (deviceId) {\n      if (this.recognizer.isListening()) {\n        await this.recognizer.stopListening()\n      }\n      // listen() takes two arguments:\n      // 1. A callback function that is invoked anytime a word is recognized.\n      // 2. A configuration object with adjustable fields\n      await this.recognizer.listen(result => {\n        this.handlePredictions(result.scores)\n      }, {\n          includeSpectrogram: false, // in case listen should return result.spectrogram\n          probabilityThreshold: 0.75,\n          invokeCallbackOnNoiseAndUnknown: true,\n          overlapFactor: 0.5, // probably want between 0.5 and 0.75. More info in README\n          audioTrackConstraints: {\n            deviceId: deviceId\n          }\n      })\n    },\n    async createModel() {\n        const baseURL = `${location.protocol}//${location.host}`\n        const checkpointURL = `${baseURL}/speech/model.json`\n        const metadataURL = `${baseURL}/speech/metadata.json`\n        const recognizer = speechCommands.create(\n            'BROWSER_FFT',\n            undefined,\n            checkpointURL,\n            metadataURL)\n        // check that model and metadata are loaded via HTTPS requests.\n        await recognizer.ensureModelLoaded()\n        return recognizer\n    },\n    handlePredictions (predictions) {\n        this.predictions.length = 0\n        \n        predictions.forEach((prediction, index) => {\n            this.predictions.push({\n              name: this.classLabels[index],\n              score: (prediction * 100).toFixed(1)\n            })\n        })\n        const pred = this.topPrediction\n        if (pred.name !== 'Background Noise') {\n          this.$emit('word', pred.name.toLowerCase())\n        }\n    }\n  }\n}\n</script>\n\n<style>\n.app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  color: #2c3e50;\n  margin-top: 60px;\n}\ntable {\n  width: 100%;\n  border-spacing: 5px;\n}\n.margin-10 {\n  margin: 10px;\n}\n.top-row {\n  background-color: rgba(0, 200, 0, 0.1);\n  height: 40px;\n  font-weight: 900;\n}\n.other-rows {\n  background-color: rgba(200, 0, 0, 0.1);\n  height: 30px;\n  font-weight: 400;\n}\ntd {\n  padding: 5px;\n}\ntd:nth-child(1) {\n  width: 70%;\n    text-align: left;\n}\ntd:nth-child(2) {\n  width: 30%;\n  text-align: center;\n}\n.center-container {\n  width: 600px;\n  margin: 0 auto;\n}\n.device-select {\n  width: 100%;\n}\n</style>"]}]}